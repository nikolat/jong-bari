//本来は他家の捨て牌とか諸々の情報が必要
string naniwokiru(array hai, array kawa)
{
	return getDahai(hai);
}

//テンパイに近づける
string getDahai(array hai)
{
	array arDahai;
	int point = -1;
	array hai14 = sortHai(hai);
	//孤立牌を優先的に切る
	array arKoritsuhai = getKoritsuHai(hai14);
	for (int i = 0; hai14[i] != nil; i++)
	{
		if (ASEARCH(hai14[i], arDahai) == -1)
		{
			array hai13 = removeElementByName(hai14, hai14[i], 1);
			array a = getShantenWithMentsu(hai13);
			int shanten13 = a[0];
			array arPattern = a[1];
			int shantenPoint = 0;
			if (shanten13 == 0)
				shantenPoint = 100000;
			else
				shantenPoint = 10000 / (shanten13 + 1);
			int mentsuPoint = 0;
			for (int j = 0; arPattern[j] != nil; j++)
			{
				int tmpPoint = 0;
				if (arPattern[j] == "chitoitsu" || arPattern[j] == "kokushimusou")
				{
					tmpPoint = 0;
				}
				else
				{
					array ap = _strsplit(arPattern[j], ",");
					array arTatsu13 = {};
					if (ap[0] != "")
					{
						tmpPoint += 10;//雀頭
					}
					for (int k = 1; ap[k] != nil; k++)
					{
						if (_strlen(ap[k]) == 6)
						{
							tmpPoint += 100;//面子
						}
						else if (_strlen(ap[k]) == 4)
						{
							arTatsu13 += ap[k];
						}
					}
					for (int k = 0; arTatsu13[k] != nil; k++)
					{
						array arTatsuNum = convertNumArray(strHaiToArray(arTatsu13[k]));
						if ((arTatsuNum[0] != 1) && (arTatsuNum[0] + 1 == arTatsuNum[1]) && (arTatsuNum[1] != 9))
							tmpPoint += 50;//両面
						else if (arTatsuNum[0] == arTatsuNum[1])
							tmpPoint += 10;//対子
						else
							tmpPoint += 30;
					}
				}
				if (mentsuPoint < tmpPoint)
					mentsuPoint = tmpPoint;
			}
			int koritsuPoint = 0;
			if (ASEARCH(hai14[i], arKoritsuhai) >= 0)
			{
				koritsuPoint += 500;
			}
			int dahaiPoint = shantenPoint + mentsuPoint + koritsuPoint;
			if (point < dahaiPoint)
			{
				point = dahaiPoint;
				arDahai = {hai14[i]};
			}
			else if (point == dahaiPoint)
			{
				arDahai += hai14[i];
			}
		}
	}
	return _randselect(arDahai);
}

//孤立牌の探索
array getKoritsuHai(array hai)
{
	array arRet;
	for (int i = 0; hai[i] != nil; i++)
	{
		int num = _substr(hai[i], 0, 1);
		string color = _substr(hai[i], 1, 1);
		if (color == "m" || color == "p" || color == "s")
		{
			string haiP2 = "" + (num - 2) + color;
			string haiP1 = "" + (num - 1) + color;
			string haiN1 = "" + (num + 1) + color;
			string haiN2 = "" + (num + 2) + color;
			if (!(ASEARCH(haiP2, hai) >= 0
				|| ASEARCH(haiP1, hai) >= 0
				|| _aryvn(ASEARCHEX(hai[i], hai)) > 1
				|| ASEARCH(haiN1, hai) >= 0
				|| ASEARCH(haiN2, hai) >= 0))
			{
				arRet += hai[i];
			}
		}
		else if (color == "z")
		{
			if (_aryvn(ASEARCHEX(hai[i], hai)) == 1)
			{
				arRet += hai[i];
			}
		}
	}
	return arRet;
}

//両面
isRyanmen(array hai)
{
	array arHai = convertNumArray(hai);
	if (arHai + 1 == arHai)
		return 1;
	return 0;
}

//============================================================
//七対子をひたすら目指す
string getDahaiForChitoitsu(array hai, array kawa)
{
	array hai14 = sortHai(hai);
	//3枚同じ牌があれば切る
	string dahai = get3SameElement(hai14);
	if (dahai != "")
		return dahai;
	//過去に切った牌をツモ切り フリテン防止(配列の最後の要素がツモである前提のため注意)
	dahai = hai[_aryvn(hai)-1];
	if (ASEARCH(dahai, kawa) >= 0)
		return dahai;
	//1枚のみの牌を切る
	dahai = getSoloElement(shuffleArray(hai14));//ランダム性が無いと待ちが字牌に偏る
	if (dahai != "")
		return dahai;
	else
		return "";//それは和了である
}

string get3SameElement(array elements)
{
	string e = elements[0];
	for (int i = 1; elements[i + 1] != nil; i++)
	{
		if (e == elements[i] && e == elements[i + 1])
		{
			return e;
		}
		else
		{
			e = elements[i];
		}
	}
	return "";
}

string getSoloElement(array elements)
{
	dict solo;
	for (int i = 0; elements[i] != nil; i++)
	{
		if (solo[elements[i]] == nil)
		{
			int isSolo = 1;
			for (int j = i + 1; elements[j] != nil; j++)
			{
				if (elements[i] == elements[j])
				{
					isSolo = 0;
					solo += $(elements[i], 0);
					break;
				}
			}
			if (isSolo)
			{
				return elements[i];
			}
		}
	}
	return "";
}
